import proxy.proxy;
import ada.wrappers;
import ada.transformations;

function wrapped_type () do
   pick child (TypeExpr ()).wrapper (te: wp_TypeExpr ());
end;

template w_ParamSpecCallProxy extends w_ParamSpecCall do
   var sb: object;
   var original_type: text;

   match origin () do
      pick origin wrap null (w_ParamSpecCall);
   end;
   
   do
      var tmp_val: text => sb.tmp ("Val");

      weave (
         type_expr => "System.Address",
         pre_call_decl => lambda (i"""
            \e<sb.tmp ("Proxy")> : aliased \e<child (wp_TypeExpr ()).name> with Address => \e<name>, Import;
            \e<tmp_val> : aliased \e<original_type> with Address => \e<sb.tmp ("Proxy")>.Address, Import;"""),
         actual_value => tmp_val);
   end;
end;

template to_proxy_struct pick origin do
   match ParamSpec() and parent (sb: SubpDecl()) and t: sb.tmp ("Value")
   wrap w_ParamSpecCallProxy (
      sb   => sb.wrapper (w_SubpDecl ()),
      original_type => child (TypeExpr));

   match sb: SubpDecl() 
      and t1: sb.tmp ("Res")
      and t2: sb.tmp ("Proxy_Res")
   wrap w: w_SubpDeclCall (
      function_or_procedure => "function",
      result_type_expr => "System.Address",
      call_decl => """\e<t1> : aliased \e<child (w_TypeExpr ())> := \e<w.call>;\n""",
      call_stmt => "null;", 
   
      post_call_decl => lambda (i"""
         \e<t2> : \e<wrapped_type().name>_Access := new \e<wrapped_type().name>'
            (Is_Proxy_Owned => True,
             Is_Automatic   => False,
             Address        => Allocate_Byte_Copy (\e<t1>'Address, \e<t1>'Size));"""
      ),
             
      return_stmt => """return \e<t2>.all'Address;"""
   );
end;

template ada2proxy_type pick origin do
   var w_param: object;

   match p_type_expression.p_designated_type_decl().f_type_def (SignedIntTypeDef ()) 
      do
         pick w_param weave (type => "int32");
         
         wrap into_explicit_conversion ("Interfaces.C.int");
      end;
   else match s: self ()
      pick w_param weave (type => "proxy_address");
end;

template generate_ada2proxy pick origin do
   wrap wrap_ada_specs ();

   match DefiningName (x"(.*)")
   wrap w_DefiningName ("Proxy_\1");

   match d: PackageDecl () do
      pick p: parent (CompilationUnit ()) do
         wrap wp_Unit (name => d.p_defining_name);

         # TODO: self should be p, for some reason it's not. To fix
         # match wrapper (x: w_Unit ()) 
         match p.wrapper (x: w_Unit ())
         pick x.child (new ({
            w_WithClause ("Interfaces.C"),
            w_WithClause ("System")
         }));
      end;

      weave w_PackageDecl (
         spec_content => @ & i"""
            function Allocate_Byte_Copy (Address : System.Address; Size : Integer) return System.Address;
         """,

         body_content => @ & i"""
            function Allocate_Byte_Copy (Address : System.Address; Size : Integer) return System.Address is
               type Byte_Array is array (Integer range 1 .. Size) of Boolean with Pack;
               type Byte_Array_Access is access all Byte_Array;

               Src : aliased Byte_Array with Address => Address;
               Dst : Byte_Array_Access := new Byte_Array'(Src);
            begin
               return Dst.all'Address;
            end Allocate_Byte_Copy;
         """
      );
   end;

   match s: SubpDecl () do
      match parent (u: wrapper (w_Unit ()))
      wrap wp: wp_Function (
         name => p_defining_name,
         type => "void",
         symbol => u.tmp (s.p_defining_name)
      );

      match child (f_subp_kind ("function")) and 
         child (TypeExpr ()).child (Identifier ()).p_referenced_decl (child (RecordTypeDef ()))
      wrap to_proxy_struct ();

      weave w: w_SubpDeclCall ();
   then
      pick w.child (new ({
         w_Aspect ("Export => True"),
         w_Aspect ("Convention => C"),
         w_Aspect ("""External_Name => "\e<wp.symbol>" """)}));
   end;

   match ParamSpec () do
      wrap w: wp_Parameter (name => p_defining_name);

      match child (TypeExpr ()).child (Identifier ()).p_referenced_decl (child (RecordTypeDef ()))
      wrap to_proxy_struct ();
   then
      wrap ada2proxy_type (w);
   end;

   match TypeExpr ()
   wrap wp_TypeExpr ();

   match type: TypeDecl () and child (RecordTypeDef ()) do
      var original_type: text => string (p_defining_name);

      wrap proxy_type: w_TypeDecl (
         declaration => i"""
            type \e<proxy_type.name> is record
               Address        : System.Address;
               Is_Proxy_Owned : Boolean;
               Is_Automatic   : Boolean;
            end record;

            type \e<proxy_type.name>_Access is access all \e<proxy_type.name>;
         """
      );
   then
      wrap wp_TypeDecl (
         name => "\e<proxy_type.name>"
      );
   then
      pick parent (PackageDecl ()).wrapper (w_PackageDecl ()) do
         pick child (new ({
            sb: w_SubpDeclCall (
               name => "\e<proxy_type.name>_Proxy_Allocate",
               function_or_procedure => "function"
            ) {
               w_ParamSpecCallProxy (
                  sb => sb, 
                  name => "Proxy",
                  original_type => original_type
               ) {
                  wp_TypeExpr (name => proxy_type.name)
               }
            },

            sb: w_SubpDeclCall (
               name => "\e<proxy_type.name>_Proxy_Free",
               function_or_procedure => "procedure"
            ) {
               w_ParamSpecCallProxy (
                  sb => sb, 
                  name => "Proxy", 
                  original_type => original_type)
               {
                  wp_TypeExpr (name => proxy_type.name)
               }
            }
         }));
      end;
   end;

   match TypeExpr ()
   wrap wp_TypeExpr (name => lambda (
      p_designated_type_decl().wrapper (wp_TypeDecl ()).name
   ));
end;
