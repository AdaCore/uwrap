template w_Ada do

end;

template w_Unit extends w_Ada do
   var spec: text;
   var body: text;

   var spec_with_clauses: text;
   var spec_use_clauses: text;
   var body_with_clauses: text;
   var body_use_clauses: text;

   var spec_text: text => i"""
   \e<spec_with_clauses>
   \e<spec_use_clauses>

   \e<spec>""";

   var body_text : text => i"""
   \e<body_with_clauses>
   \e<body_use_clauses>

   \e<body>""";
end;

template w_NamedEntity extends w_Ada do
  var name: text;
  var original_name: text;
end;

template w_WithClause extends w_Ada do
  var ref: text;
end;

template w_UseClause extends w_Ada do
  var ref: text;
end;

template w_PackageDecl extends w_NamedEntity do
   var spec_content: text;
   var body_content: text;
   var stmt: text;
   var elaborate_body: text;

   var spec: text => i"""
      package \e<name> is
        \e<elaborate_body>
        \e<spec_content>
      end \e<name>;""";

   var body: text => i"""
      package body \e<name> is
        \e<body_content>
      begin
        null;
        \e<stmt>
      end \e<name>;""";
end;

template w_SubpDecl extends w_NamedEntity do
   var function_or_procedure: text;
   var return_spec: text;
   var lparenSpec: text;
   var rparenSpec: text;

   var lparenCall: text;
   var rparenCall: text;
 
   var param_spec_list: text;
   var result_type_expr: text;

   var pre_call_decl: text;
   var pre_call_stmt: text;
   var call_decl_exp: text;
   var call_decl: text;
   var call_stmt: text;
   var post_call_decl: text;
   var post_call_stmt: text;

   var return_stmt: text;
   var call_assoc_list: text;
   var call: text;
   var call_name: text;

   var profile: text => """\e<function_or_procedure> \e<name> \e<lparenSpec> \e<param_spec_list> \e<rparenSpec> \e<return_spec>"""; 

   var spec: text; 

   var body: text => i"""
   \e<profile> is
      \e<pre_call_decl>
   begin
      \e<pre_call_stmt>
      declare
         \e<call_decl>
      begin
         \e<call_stmt>
         declare
            \e<post_call_decl>
         begin
            \e<post_call_stmt>
            \e<return_stmt>
         end;
      end;
   end \e<name>;
   """; 
end;

template w_SubpDeclCall extends w_SubpDecl do

end;

template w_SubpDeclCallback extends w_SubpDecl do
   
end;

template w_ParamSpec extends w_NamedEntity do
   var generate_formal: text;

   var formal_text: text;
   var actual_text: text;

   var type_expr: text;

   var pre_call_decl: text;
   var pre_call_stmt: text;
   var call_decl: text;
   var call_stmt: text;
   var actual_value: text;
   var post_call_decl: text;
   var post_call_stmt: text;
   var return_stmt: text;
   var result_type_expr: text;

   var mode: text;
end;

template w_ParamSpecCall extends w_ParamSpec do

end;

template w_ParamSpecCallback extends w_ParamSpec do

end;

template w_DefiningName extends w_Ada do
  var name: text;
end;

template w_TypeExpr extends w_Ada do
   var txt: text;
end;

template w_TypeDecl extends w_NamedEntity do
   var definition: text;
   var content_definition: text;
   var rep_definition: text;
   var rep_declaration: text;
   var kind: text;
   var aspects_declaration: text;

   var declaration: text => lambda (
      (match origin (IncompleteTypeDecl ())
         pick "type \e<name>;"
      else match origin (SubtypeDecl ())
         pick "subtype \e<name> is \e<definition>;"
      else
         pick "type \e<name> is \e<definition>\e<aspects_declaration>;\n\e<rep_declaration>"));
end;

template w_Aspect extends w_Ada do
   var txt: text;
end;

template w_EnumLiteralDecl extends w_NamedEntity do
  
end;

template w_EnumRep extends w_Ada do
   var name: text;
   var value: text;
end;

template w_ComponentDecl extends w_NamedEntity do
  
end;

template w_NumberDecl extends w_NamedEntity do
  
end;

template w_ObjectDecl extends w_NamedEntity do
  
end;

template spec_file extends standard.file do
end;

template body_file extends standard.file do
end;

template visit_EnumRepClause pick origin do
  var enum_decl: object;

  match AggregateAssoc () and child (i: Identifier ()) and child (v: IntLiteral ()) do
     match n: enum_decl.child (EnumLiteralDecl ("\e<i>")) # TODO, we should be able to write text (i) instead.
     pick n wrap w_EnumRep (name => lambda (n.wrapper (w_EnumLiteralDecl ()).name), value => v);
  end;
end;

template build_identifier pick origin do
   var type: object;

   # not all identifiers are wrapped - in particular those coming from the
   # standard library are not. So differenciate here the cases where we
   # find a w_DefiningName (using the provided name) from the cases where we
   # don't.

   match i: self() 
      and x: p_referenced_decl ()
      and t: x.child (DefiningName ()).wrapper (w_DefiningName ())
         pick type weave (txt => @ & " " & t.name);
      else
         pick type weave (txt => @ & " " & i);
end;

template build_dotted_name pick origin do
   var type: object;

   match s: self () and c: child (DottedName ())
   pick c do
      weave build_dotted_name (type);
      then pick type weave (txt => @ & ".");
      then pick s.child (Identifier()) wrap build_identifier (type);
      end;
   else
      match child (i1: Identifier() and next (i2: Identifier()))
         do pick type weave (txt => @ & " ");
         then pick i1 wrap build_identifier (type);
         then pick type weave (txt => @ & ".");
         then pick i2 wrap build_identifier (type);
      end;
end;

template build_type_expr pick origin do
   var type: object;

   match d: DottedName () do
      pick d wrap build_dotted_name (type);
      wrap over;
      end;
   else match i: Identifier ()
      pick i weave build_identifier (type);     
   else match RangeSpec ()
      pick type weave (txt => @ & " range");
   else match TypeAccessDef ()
      pick type weave (txt => @ & " access");
   else match s: self () and SingleTokNode()
      pick type weave (txt => @ & " \e<s>");
   else match s: IndexConstraint () do
      pick type weave (txt => @ & " (");
      then pick child ().all () weave build_type_expr (type);
      then pick type weave (txt => @ & " )");
      then wrap over;
   end;
end;

template build_subprogram pick origin do
   var sb: object;

   match sb.child (f_subp_kind ("function")) and sb.child (te: TypeExpr()) 
      weave (
         function_or_procedure => "function",
         result_type_expr => lambda (child (w_TypeExpr()).txt),
         call_decl => """\e<self.tmp ("result_orig")> : aliased \e<te> := \e<call>;\n""",
         post_call_decl => i"""
            \e<self.tmp ("result_wrapped")> : aliased \e<result_type_expr> 
            with Address => \e<self.tmp ("result_orig")>'Address, Import;\n""",
         call_stmt => "null;", 
         return_stmt => """return \e<sb.tmp ("result_wrapped")>;""");
   else
      weave (
         call_stmt => "\e<call>;", 
         return_stmt => "null;",
         function_or_procedure => "procedure");
end;

template ada_to_wrappers pick origin do
   match CompilationUnit () do
      wrap w_Unit ();
   end;

   match PackageDecl () 
   wrap w_PackageDecl();
    
   match sb: (SubpDecl() or AccessToSubpDef ()) do
      do
         wrap w: w_SubpDeclCall ();
      then
         match w () pick w weave build_subprogram (sb);
      end;
      
      do 
         wrap w: w_SubpDeclCallback();
      then 
         match w () pick w weave build_subprogram (sb);
      end;
   end;
   
   match ParamSpec() do
      wrap w_ParamSpecCall();
      wrap w_ParamSpecCallback();

      match parent (sb: (SubpDecl () or AccessToSubpDef ())) do
         wrap n: w_ParamSpecCall (
            type_expr => lambda (n.child (w_TypeExpr()).txt),
            pre_call_decl => """\e<sb.tmp ("local")> : aliased \e<p_type_expression> with Address => \e<n.name>'Address, Import;\n""",
            actual_value => sb.tmp ("local")
         );

         wrap n: w_ParamSpecCallback (
            type_expr => p_type_expression,
            pre_call_decl => """\e<sb.tmp ("local")> : aliased \e<lambda (n.child (w_TypeExpr()).txt)> with Address => \e<n.name>'Address, Import;\n""",
            actual_value => sb.tmp ("local")
         );
      end;
   end;
   
   match BaseTypeDecl () 
   wrap w_TypeDecl ();

   match TypeDecl () and child (EnumTypeDef ()) do
      wrap w_TypeDecl (
         kind => "enumeration"
      );

      match s: self () and r: p_get_enum_representation_clause ()
      pick r.child().all () wrap visit_EnumRepClause (s);
   end;

   match EnumLiteralDecl ()
   wrap w_EnumLiteralDecl();

   match ComponentDecl ()
   wrap w_ComponentDecl ();

   match WithClause() and child(d: Name ())
   wrap w_WithClause(ref => d);

   match UseClause() and child(d: Name ())
   wrap w_UseClause(ref => d);

   match TypeExpr ()
   wrap w_TypeExpr ();

   match NumberDecl ()
   wrap w_NumberDecl();

   match ObjectDecl ()
   wrap w_ObjectDecl();

   match DefiningName () do
      match parent (PackageDecl ())
      wrap w_DefiningName (name => @ & "\e<self>_Wrapped");

      match parent (BasicDecl () and parent (PackageDecl ()))
      wrap w_DefiningName (name => @ & "\e<self>");
   end;
end;

template wrappers_post_process pick origin do
   match sb: w_SubpDeclCall () 
      and parent (p : w_PackageDecl ())
   do   
      match function_or_procedure ("function")
      weave (return_spec => "return \e<result_type_expr>");

      match v: origin.p_fully_qualified_name ()
      weave (call_name => v);
      
      weave (call => "\e<call_name> \e<lparenCall> \e<call_assoc_list> \e<rparenCall>");

      match child (w_ParamSpecCall(not generate_formal ("NO")))
      weave (lparenSpec => "(", rparenSpec => ")");

      match child (c: w_ParamSpecCall())
      weave (lparenCall => "(", rparenCall => ")");

      match origin (SubpDecl ())
      pick p weave (spec_content => @ & sb.spec & "\n\n", body_content => @ & sb.body);

      match child (w_Aspect ())
         weave (spec => i"""
            \e<profile> with 
               \e<child (a: w_Aspect ()).fold (c: "", c: (c & a.txt), c: (c & ",\n"))>;""");
      else
         weave (spec => profile & ";");
   end;

   match sb: w_SubpDeclCallback() 
      and parent (p : w_PackageDecl ()) 
   do   
      match function_or_procedure ("function")
      weave (return_spec => "return \e<result_type_expr>");

      match v: origin.p_fully_qualified_name ()
      weave (call_name => v);
      
      weave (call => "\e<call_name> \e<lparenCall> \e<call_assoc_list> \e<rparenCall>");

      match child (w_ParamSpecCallback (not generate_formal ("NO")))
      weave (lparenSpec => "(", rparenSpec => ")");

      match child (c: w_ParamSpecCallback())
      weave (lparenCall => "(", rparenCall => ")");
   end;

   match p: w_ParamSpecCall() and parent (s: w_SubpDeclCall()) do
      match not generate_formal ("NO") do
         match prev (w_ParamSpecCall (not generate_formal ("NO")))
         weave (
            formal_text => @ & "; \e<name> : \e<mode> \e<type_expr>");
         else weave (
            formal_text => @ & "\e<name> : \e<mode> \e<type_expr>");
      end;

      match prev (w_ParamSpecCall ())
      weave (actual_text => @ & ", \e<actual_value>");
      else weave (actual_text => @ & "\e<actual_value>");

      pick s weave (
         param_spec_list  => @ & p.formal_text,
         pre_call_decl    => @ & p.pre_call_decl,
         pre_call_stmt    => @ & p.pre_call_stmt,
         call_decl        => @ & p.call_decl,
         call_stmt        => @ & p.call_stmt,
         call_assoc_list  => @ & p.actual_text,
         post_call_decl   => @ & p.post_call_decl,
         post_call_stmt   => @ & p.post_call_stmt,
         return_stmt      => @ & p.return_stmt,
         result_type_expr => @ & p.result_type_expr
      );
   end;

   match p: w_ParamSpecCallback() and parent (s: w_SubpDeclCallback()) do
      match not generate_formal ("NO") do
         match prev (w_ParamSpecCallback (not generate_formal ("NO")))
         weave (
            formal_text => @ & "; \e<name> : \e<mode> \e<type_expr>");
         else weave (
            formal_text => @ & "\e<name> : \e<mode> \e<type_expr>");
      end;

      match prev (w_ParamSpecCallback ())
      weave (actual_text => @ & ", \e<actual_value>");
      else weave (actual_text => @ & "\e<actual_value>");

      pick s weave (
         param_spec_list  => @ & p.formal_text,
         pre_call_decl    => @ & p.pre_call_decl,
         pre_call_stmt    => @ & p.pre_call_stmt,
         call_decl        => @ & p.call_decl,
         call_stmt        => @ & p.call_stmt,
         call_assoc_list  => @ & p.actual_text,
         post_call_decl   => @ & p.post_call_decl,
         post_call_stmt   => @ & p.post_call_stmt,
         return_stmt      => @ & p.return_stmt,
         result_type_expr => @ & p.result_type_expr
      );
   end;

   match s: w_ObjectDecl() and parent (p : w_PackageDecl()) and child (te: w_TypeExpr ())
   pick p weave (spec_content => @ & "\e<s.name> : \e<te.txt>;\n");
   

   match s: w_ComponentDecl () and parent (t: w_TypeDecl ()) and child (te: w_TypeExpr ())
   pick t weave (
      content_definition => @ & "\e<s.name> : \e<te.txt>;\n"
   );

   match s: w_EnumLiteralDecl() and parent (p: w_TypeDecl ()) do
      match prev (w_EnumLiteralDecl ())
         pick p weave (content_definition => @ & ", \e<s.name>");
      else
         pick p weave (content_definition => @ & "\e<s.name>");
   end;

   match e: w_EnumRep() and parent (p: w_TypeDecl ()) do
      match prev (w_EnumRep())
         pick p weave (rep_definition => @ & ", \e<e.name> => \e<e.value>\n"); 
      else 
         pick p weave (rep_definition => @ & "\e<e.name> => \e<e.value>\n");
   end;

   match w: w_Aspect() and parent (p: w_TypeDecl ()) do
      match prev (w_Aspect ())
         pick p weave (aspects_declaration => @ & ", \e<w.txt>\n"); 
      else 
         pick p weave (aspects_declaration => @ & "with \e<w.txt>\n");
   end;

   match top: w_TypeDecl () do
      match origin (t: child (TypeAccessDef ())) 
         weave (definition => @ & " access \e<child (w_TypeExpr ()).txt>");
      else match origin (t: child (DerivedTypeDef ())) 
         weave (definition => @ & "new \e<child (w_TypeExpr ()).txt>");
      else 
         match origin (
            t: child (ArrayTypeDef (
            i: child (UnconstrainedArrayIndex () or ConstrainedArrayIndices)))) 
         do
            match i (UnconstrainedArrayIndex ()) and i.child (wrapper (w1 : w_TypeExpr ()))
            weave (definition => @ & "array (\e<w1.txt> range <>) of \e<child (w_TypeExpr ()).txt>");
            else weave (definition => @ & "array (\e<t.child(ConstraintList ())>) of \e<child (w_TypeExpr ()).txt>");
         end;
      else 
         match origin (child (AccessToSubpDef ())) do
            match origin (child (t: TypeDef ())) 
            weave (definition => @ & "\e<t>");

            match child (cl: w_SubpDeclCall ()) and child (cb: w_SubpDeclCallback ()) 
               and parent (p: w_PackageDecl()) 
               and ncall: top.tmp ("Call")
            do 
               pick cl weave (name => ncall);
               pick cb weave (
                  name => top.name & "_Gen", 
                  call_name => ncall);

               pick p weave (
                  spec_content => @ & i"""
                     generic 
                        with \e<cl.profile>;
                     \e<cb.profile>;""",
                  body_content => @ & """\e<cb.body>""");
            end;
         end;
      else 
         match origin (child (RecordTypeDef ())) do
            match child (w_ComponentDecl())
               weave (definition => @ & i"""
                  record
                     \e<content_definition>
                  end record""");
            else
               weave (definition => @ & "null record");
         end;
      else match kind ("enumeration") # TODO: this whole test should be using enumeration instead
         weave (definition => @ & "(\e<content_definition>)");
      else match origin (child (t: TypeDef ())) 
         weave (definition => @ & "\e<t>");
      else match child (t: w_TypeExpr())
         weave (definition => @ & "\e<t.txt>");

      match child (w_EnumRep ())
      weave (rep_declaration => @ & "for \e<name> use (\n\e<rep_definition>\n);\n");
      
      match s: self () and not parent (w_TypeExpr ()) and parent (p: w_PackageDecl())
      pick p weave (spec_content => @ & s.declaration & "\n");
   end;

   match s: w_TypeExpr (o: origin (child (Identifier ())))
   pick self.origin ().child ().all() weave build_type_expr (s);
    
   match p: w_PackageDecl (parent (u: w_Unit ())) do
      pick u weave (
         spec => @ & p.spec,
         body => @ & p.body
      );
    
      match p.origin ()
      pick u weave (
         body_with_clauses => @ & "with \e<p.original_name>;\n",
         body_use_clauses => @ & "use \e<p.original_name>;\n"
      );
   end;

   match ((w: w_WithClause () and c: has ("with")) or (w: w_UseClause () and c: has ("use")))
      and parent (u: w_Unit ())
   do
      match origin (child (r: Name()))
        and (r.p_referenced_decl ().wrapper (child (n: w_DefiningName ())))
      pick u weave (
         spec_with_clauses => @ & "\e<c> \e<n.name>; \e<c> \e<w.ref>;\n");
      else pick u weave (
         spec_with_clauses => @ & "\e<c> \e<w.ref>;\n"
      );
   end;

   match n: w_NamedEntity () 
      and child (s: w_DefiningName ()) 
      and n.name (x"^$")
   do
      match v: n.origin.p_fully_qualified_name ()
         weave (name => s.name, original_name => v);
      else
         weave (name => s.name);
   end;
   
   match w_Unit () and child (p: w_PackageDecl ()) do
      wrap spec_file
         (path => lambda (replace_text (to_lower (p.name), "\\.", "-")) & ".ads", content => self.spec_text);

      match child (w_SubpDecl ()) or p (elaborate_body (x".+"))
      wrap body_file 
         (path => lambda (replace_text (to_lower (p.name), "\\.", "-")) & ".adb", content => self.body_text);
   end;
end;

template wrap_ada_specs do
   wrap null (wrap_ada_specs);

   pick origin do
      match AdaNode () wrap ada_to_wrappers ();
      match w_Ada () wrap wrappers_post_process ();
   end;
end;
