template w_Ada {
  
}

template w_Unit extends w_Ada {
   var spec : text;
   var body : text;

   var spec_with_clauses : text;
   var spec_use_clauses : text;
   var body_with_clauses : text;
   var body_use_clauses : text;

   var spec_text : pattern ("""
   \e<spec_with_clauses>
   \e<spec_use_clauses>

   \e<spec>
   """);

   var body_text : pattern ("""
   \e<body_with_clauses>
   \e<body_use_clauses>

   \e<body>
   """);
}

template w_NamedEntity extends w_Ada {
  var name : text;
  var original_name : text;
}

template w_WithClause extends w_Ada {
  var ref : text;
}

template w_UseClause extends w_Ada {
  var ref : text;
}

template w_PackageDecl extends w_NamedEntity {
   var spec_content : text;
   var body_content : text;

   var spec : pattern ("""
      package \e<name> is
        \e<spec_content>
      end \e<name>; 
      """);

   var body : pattern ("""
      package body \e<name> is
        \e<body_content>
      end \e<name>;
   """);
}

template w_SubpDecl extends w_NamedEntity {
   var function_or_procedure : text;
   var return_spec : text;
   var lparenSpec : text;
   var rparenSpec : text;

   var lparenCall : text;
   var rparenCall : text;
 
   var param_spec_list : text;
   var result_type_expr : text;

   var pre_call_decl : text;
   var pre_call_stmt : text;
   var call_decl_exp : text;
   var call_decl : text;
   var call_stmt : text;
   var post_call_decl : text;
   var post_call_stmt : text;

   var return_stmt : text;
   var call_assoc_list : text;
   var call : text;

   var profile : pattern ("""
   \e<function_or_procedure> \e<name> \e<lparenSpec> \e<param_spec_list> \e<rparenSpec> \e<return_spec>
   """); 

   var spec : pattern ("""
   \e<profile>;
   """); 

   var body : pattern ("""
   \e<profile> is
      \e<pre_call_decl>
   begin
      \e<pre_call_stmt>
      declare
         \e<call_decl>
      begin
         \e<call_stmt>
         declare
            \e<post_call_decl>
         begin
            \e<post_call_stmt>
            \e<return_stmt>
         end;
      end;
   end \e<name>;
   """); 
}

template w_ParamSpec extends w_NamedEntity {
   var generate_formal : text;

   var formal_text : text;
   var actual_text : text;

   var type_expr : text;

   var pre_call_decl  : text;
   var pre_call_stmt  : text;
   var call_decl  : text;
   var call_stmt  : text;
   var actual_value   : text;
   var post_call_decl : text;
   var post_call_stmt : text;
   var return_stmt    : text;
   var result_type_expr : text;

   var mode           : text;
}

template w_DefiningName extends w_Ada {
  var name : text;
}

template w_TypeExpr extends w_Ada {
   var txt : text;
}

template w_TypeDecl extends w_NamedEntity {
   var definition : text;
   var content_definition : text;
   var rep_definition : text;
   var rep_declaration : text;
   var kind : text;
   var aspects_declaration : text;
}

template w_Aspect extends w_Ada {
   var txt : text;
}

template w_EnumLiteralDecl extends w_NamedEntity {
  
}

template w_EnumRep extends w_Ada {
   var name : text;
   var value : text;
}

template w_ComponentDecl extends w_NamedEntity {
  
}

template w_NumberDecl extends w_NamedEntity {
  
}

template spec_file extends standard.file {}

template body_file extends standard.file {}

visitor visit_EnumRepClause (enum_decl) {
  match AggregateAssoc () and child (i: Identifier ()) and child (v: IntLiteral ()) {
     match n: enum_decl.child (EnumLiteralDecl ("\e<i>")) # TODO, we should be able to write text (i) instead.
     wrap n with w_EnumRep (name => lambda (n.template (w_EnumLiteralDecl ()).name), value => v);
  }
}

visitor ada_to_wrappers () {
   match CompilationUnit () {
      wrap with w_Unit ();
   }

   match PackageDecl () 
   wrap with w_PackageDecl();
    
   match SubpDecl() {
      wrap with w_SubpDecl
         (call_stmt => "\e<call>;", 
          return_stmt => "null;",
          function_or_procedure => "procedure");

      match child (f_subp_kind ("function")) and child (te: TypeExpr()) 
      wrap with w_SubpDecl
         (function_or_procedure => "function",
          result_type_expr => lambda (new.child (w_TypeExpr()).txt),
          call_decl => "\e<self.tmp ('result_orig')> : aliased \e<te> := \e<call>;\n",
          post_call_decl => "\e<self.tmp ('result_wrapped')> : aliased \e<result_type_expr> with Address => \e<self.tmp ('result_orig')>'Address, Import;\n",
          call_stmt => "null;", 
          return_stmt => "return \e<self.tmp ('result_wrapped')>;");
   }

   match ParamSpec() and parent (sb: SubpDecl ())
   wrap with w_ParamSpec(
      type_expr => lambda (new.child (w_TypeExpr()).txt),
      pre_call_decl => "\e<sb.tmp ('local')> : aliased \e<p_type_expression> with Address => \e<name>'Address, Import;\n",
      actual_value => sb.tmp ('local')
   );

   match TypeDecl ()
   wrap with w_TypeDecl ();

   match TypeDecl () and child (EnumTypeDef ()) {
      wrap with w_TypeDecl (
         kind => "enumeration"
      );

      match r: p_get_enum_representation_clause ()
      wrap all r with visit_EnumRepClause (self);
   }

   match EnumLiteralDecl () {
      wrap with w_EnumLiteralDecl();
   }

   match ComponentDecl ()
   wrap with w_ComponentDecl ();

   match WithClause() and child(d: DottedName ())
   wrap with w_WithClause(ref => d);

   match UseClause() and child(d: DottedName ())
   wrap with w_UseClause(ref => d);

   match TypeExpr ()
   wrap with w_TypeExpr ();

   match NumberDecl ()
   wrap with w_NumberDecl();

   match DefiningName () {
      match parent (PackageDecl ())
      wrap with w_DefiningName (name => "\e<self>_Wrapped");

      match parent (BasicDecl () and parent (PackageDecl ()))
      wrap with w_DefiningName (name => "\e<self>");
   }
}

visitor wrappers_post_process () {
    match w_SubpDecl() and parent (p : w_PackageDecl ()) {
      match function_or_procedure ("function")
      weave with (return_spec => "return \e<result_type_expr>");

      weave with (
         call => "\e<origin.p_fully_qualified_name> \e<lparenCall> \e<call_assoc_list> \e<rparenCall>"
      );

      match child (w_ParamSpec(not generate_formal ("NO")))
      weave with (lparenSpec => "(", rparenSpec => ")");

      match child (c: w_ParamSpec())
      weave with (lparenCall => "( ", rparenCall => ")");

      weave p with (spec_content => self.spec, body_content => self.body);
    }

    match w_ParamSpec() and parent (s : w_SubpDecl()) {
       match not generate_formal ("NO") {
          match prev (w_ParamSpec (not generate_formal ("NO")))
          weave with (
             formal_text => "; \e<name> : \e<mode> \e<type_expr>");
          else weave with (
             formal_text => "\e<name> : \e<mode> \e<type_expr>");
       }

       match prev (w_ParamSpec ())
       weave with (actual_text => ", \e<actual_value>");
       else weave with (actual_text => "\e<actual_value>");

       weave s with (
          param_spec_list => formal_text,
          pre_call_decl => pre_call_decl,
          pre_call_stmt => pre_call_stmt,
          call_decl => call_decl,
          call_stmt => call_stmt,
          call_assoc_list => actual_text,
          post_call_decl => post_call_decl,
          post_call_stmt => post_call_stmt,
          return_stmt => return_stmt,
          result_type_expr => result_type_expr
       );
    }

    match w_ComponentDecl () and parent (t: w_TypeDecl ()) and child (te: w_TypeExpr ()) {
      weave t with (
         content_definition => "\e<name> : \e<te.txt>;\n"
      );
    }

    match w_EnumLiteralDecl() and parent (p: w_TypeDecl ()) {
       match prev (w_EnumLiteralDecl ())
          weave p with (content_definition => ", \e<name>");
       else
          weave p with (content_definition => "\e<name>");
    }

    match w_EnumRep() and parent (p: w_TypeDecl ()) {
      match prev (w_EnumRep())
         weave p with (rep_definition => ", \e<name> => \e<value>\n"); 
      else 
         weave p with (rep_definition => "\e<name> => \e<value>\n");
    }

    match w_Aspect() and parent (p: w_TypeDecl ()) {
      match prev (w_Aspect ())
         weave p with (aspects_declaration => ", \e<txt>\n"); 
      else 
         weave p with (aspects_declaration => "with \e<txt>\n");
    }

    match w_TypeDecl () {
       match origin (t: child (TypeAccessDef ())) 
          weave with (definition => "access \e<child (w_TypeExpr ()).txt>");
       else match origin (child (RecordTypeDef ()))
          weave with (definition => """
            record
               \e<content_definition>
             end record""");
       else match kind ("enumeration") # TODO: this whole test should be using enumeration instead
          weave with (definition => "(\e<content_definition>)");
       else match origin (child (t: TypeDef ())) 
          weave with (definition => "\e<t>");

       match child (w_EnumRep ()) {
          weave with (rep_declaration => "for \e<name> use (\n\e<rep_definition>\n);\n");
       }

       match not parent (w_TypeExpr ()) and parent (p: w_PackageDecl())
       weave p with (spec_content => "type \e<name> is \e<definition>\e<aspects_declaration>;\n\e<rep_declaration>");
       else match parent (p: w_TypeExpr ())
       weave p with (txt => definition);
    }

    match w_TypeExpr (o: origin (child (i: Identifier ()))) {
      match o.p_designated_type_decl.template (w: w_TypeDecl ())
      weave with (txt => w.name);
      else weave with (txt => o);
    }
    
    match p: w_PackageDecl (parent (u: w_Unit ()))
    weave u with 
        (spec => p.spec,
         body => p.body,
         body_with_clauses => "with \e<p.original_name>;\n",
         body_use_clauses => "use \e<p.original_name>;\n");

    match w_WithClause () and parent (u: w_Unit ())
    weave u with (
       spec_with_clauses => "with \e<ref>;\n",
       body_with_clauses => "with \e<ref>;\n"
    );

    match w_UseClause () and parent (u: w_Unit ())
    weave u with (
       spec_with_clauses => "use \e<ref>;\n",
       body_with_clauses => "use \e<ref>;\n"
    );

    match w_DefiningName () and parent (n: w_NamedEntity ())
    weave n with (name => self.name, original_name => n.origin.p_fully_qualified_name);

    match w_Unit () and child (p: w_PackageDecl ()) {
      #TODO: we should be using labels instead of extending standard.file
      wrap with spec_file (path => "\e<to_lower (p.name)>.ads", content => self.spec_text); 
      wrap with body_file (path => "\e<to_lower (p.name)>.adb", content => self.body_text);
    }
}

visitor wrap_ada_specs () {
   match AdaNode ()
   wrap with ada_to_wrappers ();

   match w_Ada ()
   wrap with wrappers_post_process ();
}
