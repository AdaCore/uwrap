template w_Ada {
  
}

template w_Unit extends w_Ada {
   var spec : text;
   var body : text;

   var spec_with_clauses : text;
   var spec_use_clauses : text;
   var body_with_clauses : text;
   var body_use_clauses : text;

   var spec_text : pattern ("""
   \e<spec_with_clauses>
   \e<spec_use_clauses>

   \e<spec>
   """);

   var body_text : pattern ("""
   \e<body_with_clauses>
   \e<body_use_clauses>

   \e<body>
   """);
}

template w_NamedEntity extends w_Ada {
  var name : text;
  var original_name : text;
}

template w_WithClause extends w_Ada {
  var ref : text;
}

template w_UseClause extends w_Ada {
  var ref : text;
}

template w_PackageDecl extends w_NamedEntity {
   var spec_content : text;
   var body_content : text;
   var stmt : text;
   var elaborate_body : text;

   var spec : pattern ("""
      package \e<name> is
        \e<elaborate_body>
        \e<spec_content>
      end \e<name>; 
      """);

   var body : pattern ("""
      package body \e<name> is
        \e<body_content>
      begin
        null;
        \e<stmt>
      end \e<name>;
   """);
}

template w_SubpDecl extends w_NamedEntity {
   var function_or_procedure : text;
   var return_spec : text;
   var lparenSpec : text;
   var rparenSpec : text;

   var lparenCall : text;
   var rparenCall : text;
 
   var param_spec_list : text;
   var result_type_expr : text;

   var pre_call_decl : text;
   var pre_call_stmt : text;
   var call_decl_exp : text;
   var call_decl : text;
   var call_stmt : text;
   var post_call_decl : text;
   var post_call_stmt : text;

   var return_stmt : text;
   var call_assoc_list : text;
   var call : text;
   var call_name : text;

   var profile : pattern ("""
   \e<function_or_procedure> \e<name> \e<lparenSpec> \e<param_spec_list> \e<rparenSpec> \e<return_spec>"""); 

   var spec : pattern ("""
   \e<profile>;
   """); 

   var body : pattern ("""
   \e<profile> is
      \e<pre_call_decl>
   begin
      \e<pre_call_stmt>
      declare
         \e<call_decl>
      begin
         \e<call_stmt>
         declare
            \e<post_call_decl>
         begin
            \e<post_call_stmt>
            \e<return_stmt>
         end;
      end;
   end \e<name>;
   """); 
}

template w_SubpDeclCall extends w_SubpDecl {

}

template w_SubpDeclCallback extends w_SubpDecl {
   
}

template w_ParamSpec extends w_NamedEntity {
   var generate_formal : text;

   var formal_text : text;
   var actual_text : text;

   var type_expr : text;

   var pre_call_decl  : text;
   var pre_call_stmt  : text;
   var call_decl  : text;
   var call_stmt  : text;
   var actual_value   : text;
   var post_call_decl : text;
   var post_call_stmt : text;
   var return_stmt    : text;
   var result_type_expr : text;

   var mode           : text;
}

template w_ParamSpecCall extends w_ParamSpec {

}

template w_ParamSpecCallback extends w_ParamSpec {

}

template w_DefiningName extends w_Ada {
  var name : text;
}

template w_TypeExpr extends w_Ada {
   var txt : text;
}

template w_TypeDecl extends w_NamedEntity {
   var definition : text;
   var content_definition : text;
   var rep_definition : text;
   var rep_declaration : text;
   var kind : text;
   var aspects_declaration : text;
}

template w_Aspect extends w_Ada {
   var txt : text;
}

template w_EnumLiteralDecl extends w_NamedEntity {
  
}

template w_EnumRep extends w_Ada {
   var name : text;
   var value : text;
}

template w_ComponentDecl extends w_NamedEntity {
  
}

template w_NumberDecl extends w_NamedEntity {
  
}

template w_ObjectDecl extends w_NamedEntity {
  
}

template spec_file extends standard.file {}

template body_file extends standard.file {}

visitor visit_EnumRepClause (enum_decl) {
  match AggregateAssoc () and child (i: Identifier ()) and child (v: IntLiteral ()) {
     match n: enum_decl.child (EnumLiteralDecl ("\e<i>")) # TODO, we should be able to write text (i) instead.
     pick n wrap w_EnumRep (name => lambda (n.template (w_EnumLiteralDecl ()).name), value => v);
  }
}

visitor build_identifier (type) {
   # not all identifiers are wrapped - in particular those coming from the
   # standard library are not. So differenciate here the cases where we
   # find a w_DefiningName (using the provided name) from the cases where we
   # don't.

   match i: self() 
      and x: p_referenced_decl ()
      and t: x.child (DefiningName ()).template (w_DefiningName ())
         pick type weave (txt => @ & " " & t.name);
      else
         pick type weave (txt => @ & " " & i);
}

visitor build_dotted_name (type) {
   match s: self () and c: child (DottedName ()) {
      pick c {
         do weave build_dotted_name (type);
         then pick type weave (txt => @ & ".");
         then pick s.child (Identifier()) wrap build_identifier (type); end;
      }
   } else {
      match child (i1: Identifier() and next (i2: Identifier())) {
         do pick type weave (txt => @ & " ");
         then pick i1 wrap build_identifier (type);
         then pick type weave (txt => @ & ".");
         then pick i2 wrap build_identifier (type); end;
      }
   }
}

visitor build_type_expr (type) {  
   match d: DottedName () {
      pick d wrap build_dotted_name (type);
      wrap over;
   } else match i: Identifier () {
      pick i weave build_identifier (type);     
   } else match RangeSpec ()
      pick type weave (txt => @ & " range");
   else match TypeAccessDef ()
      pick type weave (txt => @ & " access");
   else match s: self () and SingleTokNode()
      pick type weave (txt => @ & " \e<s>");
   else match s: IndexConstraint () {
      do pick type weave (txt => @ & " (");
      then pick child ().all () weave build_type_expr (type);
      then pick type weave (txt => @ & " )"); end;
      
      wrap over;
   }
}

visitor build_subprogram (sb) {
   match sb.child (f_subp_kind ("function")) and sb.child (te: TypeExpr()) 
      weave (
         function_or_procedure => "function",
         result_type_expr => lambda (child (w_TypeExpr()).txt),
         call_decl => """\e<self.tmp ("result_orig")> : aliased \e<te> := \e<call>;\n""",
         post_call_decl => """
            \e<self.tmp ("result_wrapped")> : aliased \e<result_type_expr> 
            with Address => \e<self.tmp ("result_orig")>'Address, Import;\n""",
         call_stmt => "null;", 
         return_stmt => """return \e<sb.tmp ("result_wrapped")>;""");
   else
      weave (
         call_stmt => "\e<call>;", 
         return_stmt => "null;",
         function_or_procedure => "procedure");
}

visitor ada_to_wrappers () {
   match CompilationUnit () {
      wrap w_Unit ();
   }

   match PackageDecl () 
   wrap w_PackageDecl();
    
   match sb: (SubpDecl() or AccessToSubpDef ()) {
      do
         wrap w: w_SubpDeclCall ();
      then
         match w () pick w weave build_subprogram (sb);
      end;
      
      do 
         wrap w: w_SubpDeclCallback();
      then 
         match w () pick w weave build_subprogram (sb);
      end;
   }
   
   match ParamSpec() {
      wrap w_ParamSpecCall();
      wrap w_ParamSpecCallback();

      match parent (sb: (SubpDecl () or AccessToSubpDef ())) {
         wrap w_ParamSpecCall (
            type_expr => lambda (new.child (w_TypeExpr()).txt),
            pre_call_decl => """\e<sb.tmp ("local")> : aliased \e<p_type_expression> with Address => \e<name>'Address, Import;\n""",
            actual_value => sb.tmp ("local")
         );

         wrap w_ParamSpecCallback(
            type_expr => p_type_expression,
            pre_call_decl => """\e<sb.tmp ("local")> : aliased \e<lambda (new.child (w_TypeExpr()).txt)> with Address => \e<name>'Address, Import;\n""",
            actual_value => sb.tmp ("local")
         );
      }   
   } 
   
   match BaseTypeDecl () 
   wrap w_TypeDecl ();

   match TypeDecl () and child (EnumTypeDef ()) {
      wrap w_TypeDecl (
         kind => "enumeration"
      );

      match s: self () and r: p_get_enum_representation_clause ()
      pick r.child().all () wrap visit_EnumRepClause (s);
   }

   match EnumLiteralDecl ()
   wrap w_EnumLiteralDecl();

   match ComponentDecl ()
   wrap w_ComponentDecl ();

   match WithClause() and child(d: Name ())
   wrap w_WithClause(ref => d);

   match UseClause() and child(d: Name ())
   wrap w_UseClause(ref => d);

   match TypeExpr ()
   wrap w_TypeExpr ();

   match NumberDecl ()
   wrap w_NumberDecl();

   match ObjectDecl ()
   wrap w_ObjectDecl();

   match DefiningName () {
      match parent (PackageDecl ())
      wrap w_DefiningName (name => @ & "\e<self>_Wrapped");

      match parent (BasicDecl () and parent (PackageDecl ()))
      wrap w_DefiningName (name => @ & "\e<self>");
   }
}

visitor wrappers_post_process () {
   match sb: w_SubpDeclCall() 
      and parent (p : w_PackageDecl ()) {
      
      match function_or_procedure ("function")
      weave (return_spec => "return \e<result_type_expr>");

      match v: origin.p_fully_qualified_name ()
      weave (call_name => v);
      
      weave (call => "\e<call_name> \e<lparenCall> \e<call_assoc_list> \e<rparenCall>");

      match child (w_ParamSpecCall(not generate_formal ("NO")))
      weave (lparenSpec => "(", rparenSpec => ")");

      match child (c: w_ParamSpecCall())
      weave (lparenCall => "(", rparenCall => ")");

      match origin (SubpDecl ())
      pick p weave (spec_content => @ & sb.spec, body_content => @ & sb.body);
   }

   match sb: w_SubpDeclCallback() 
      and parent (p : w_PackageDecl ()) {
      
      match function_or_procedure ("function")
      weave (return_spec => "return \e<result_type_expr>");

      match v: origin.p_fully_qualified_name ()
      weave (call_name => v);
      
      weave (call => "\e<call_name> \e<lparenCall> \e<call_assoc_list> \e<rparenCall>");

      match child (w_ParamSpecCallback(not generate_formal ("NO")))
      weave (lparenSpec => "(", rparenSpec => ")");

      match child (c: w_ParamSpecCallback())
      weave (lparenCall => "(", rparenCall => ")");
   }

   match p: w_ParamSpecCall() and parent (s: w_SubpDeclCall()) {
      match not generate_formal ("NO") {
         match prev (w_ParamSpecCall (not generate_formal ("NO")))
         weave (
            formal_text => @ & "; \e<name> : \e<mode> \e<type_expr>");
         else weave (
            formal_text => @ & "\e<name> : \e<mode> \e<type_expr>");
      }

      match prev (w_ParamSpecCall ())
      weave (actual_text => @ & ", \e<actual_value>");
      else weave (actual_text => @ & "\e<actual_value>");

      pick s weave (
         param_spec_list  => @ & p.formal_text,
         pre_call_decl    => @ & p.pre_call_decl,
         pre_call_stmt    => @ & p.pre_call_stmt,
         call_decl        => @ & p.call_decl,
         call_stmt        => @ & p.call_stmt,
         call_assoc_list  => @ & p.actual_text,
         post_call_decl   => @ & p.post_call_decl,
         post_call_stmt   => @ & p.post_call_stmt,
         return_stmt      => @ & p.return_stmt,
         result_type_expr => @ & p.result_type_expr
      );
   }

   match p: w_ParamSpecCallback() and parent (s: w_SubpDeclCallback()) {
      match not generate_formal ("NO") {
         match prev (w_ParamSpecCallback (not generate_formal ("NO")))
         weave (
            formal_text => @ & "; \e<name> : \e<mode> \e<type_expr>");
         else weave (
            formal_text => @ & "\e<name> : \e<mode> \e<type_expr>");
      }

      match prev (w_ParamSpecCallback ())
      weave (actual_text => @ & ", \e<actual_value>");
      else weave (actual_text => @ & "\e<actual_value>");

      pick s weave (
         param_spec_list  => @ & p.formal_text,
         pre_call_decl    => @ & p.pre_call_decl,
         pre_call_stmt    => @ & p.pre_call_stmt,
         call_decl        => @ & p.call_decl,
         call_stmt        => @ & p.call_stmt,
         call_assoc_list  => @ & p.actual_text,
         post_call_decl   => @ & p.post_call_decl,
         post_call_stmt   => @ & p.post_call_stmt,
         return_stmt      => @ & p.return_stmt,
         result_type_expr => @ & p.result_type_expr
      );
   }

   match s: w_ObjectDecl() and parent (p : w_PackageDecl()) and child (te: w_TypeExpr ()) {
      pick p weave (spec_content => @ & "\e<s.name> : \e<te.txt>;\n");
   }

   match s: w_ComponentDecl () and parent (t: w_TypeDecl ()) and child (te: w_TypeExpr ()) {
      pick t weave (
         content_definition => @ & "\e<s.name> : \e<te.txt>;\n"
      );
   }

   match s: w_EnumLiteralDecl() and parent (p: w_TypeDecl ()) {
      match prev (w_EnumLiteralDecl ())
         pick p weave (content_definition => @ & ", \e<s.name>");
      else
         pick p weave (content_definition => @ & "\e<s.name>");
   }

   match e: w_EnumRep() and parent (p: w_TypeDecl ()) {
      match prev (w_EnumRep())
         pick p weave (rep_definition => @ & ", \e<e.name> => \e<e.value>\n"); 
      else 
         pick p weave (rep_definition => @ & "\e<e.name> => \e<e.value>\n");
   }

   match w: w_Aspect() and parent (p: w_TypeDecl ()) {
      match prev (w_Aspect ())
         pick p weave (aspects_declaration => @ & ", \e<w.txt>\n"); 
      else 
         pick p weave (aspects_declaration => @ & "with \e<w.txt>\n");
   }

   match top: w_TypeDecl () {
      match origin (t: child (TypeAccessDef ())) 
         weave (definition => @ & " access \e<child (w_TypeExpr ()).txt>");
      else match origin (t: child (DerivedTypeDef ())) 
         weave (definition => @ & "new \e<child (w_TypeExpr ()).txt>");
      else match origin (t: child (ArrayTypeDef (i: child (UnconstrainedArrayIndex ())))) {
         match i.child (template (w1 : w_TypeExpr ()))
         weave (definition => @ & "array (\e<w1.txt> range <>) of \e<child (w_TypeExpr ()).txt>");
      } else match origin (child (AccessToSubpDef ())) {
         match origin (child (t: TypeDef ())) 
         weave (definition => @ & "\e<t>");

         match child (cl: w_SubpDeclCall ()) and child (cb: w_SubpDeclCallback ()) 
            and parent (p: w_PackageDecl()) 
            and ncall: top.tmp ("Call") {
            
            pick cl weave (name => ncall);
            pick cb weave (
               name => top.name & "_Gen", 
               call_name => ncall);

            pick p weave (
               spec_content => @ & """
                  generic 
                     with \e<cl.profile>;
                  \e<cb.profile>;""",
               body_content => @ & """
               \e<cb.body>
               """);
         }
      } else match origin (child (RecordTypeDef ())) {
         match child (w_ComponentDecl())
            weave (definition => @ & """
               record
                  \e<content_definition>
               end record""");
         else
            weave (definition => @ & "null record");
      }
      else match kind ("enumeration") # TODO: this whole test should be using enumeration instead
         weave (definition => @ & "(\e<content_definition>)");
      else match origin (child (t: TypeDef ())) 
         weave (definition => @ & "\e<t>");
      else match child (t: w_TypeExpr())
         weave (definition => @ & "\e<t.txt>");

      match child (w_EnumRep ()) {
         weave (rep_declaration => @ & "for \e<name> use (\n\e<rep_definition>\n);\n");
      }

      match s: self () and not parent (w_TypeExpr ()) and parent (p: w_PackageDecl()) {
         match origin (IncompleteTypeDecl ())
            pick p weave (spec_content => @ & "type \e<s.name>;\n");
         else match origin (SubtypeDecl ())
            pick p weave (spec_content => @ & "subtype \e<s.name> is \e<s.definition>;\n");
         else
            pick p weave (spec_content => @ & "type \e<s.name> is \e<s.definition>\e<s.aspects_declaration>;\n\e<s.rep_declaration>");
      }
   }

   match s: w_TypeExpr (o: origin (child (Identifier ())))
   pick self.origin ().child ().all() weave build_type_expr (s);
    
   match p: w_PackageDecl (parent (u: w_Unit ())) {
      pick u weave (
         spec => @ & p.spec,
         body => @ & p.body
      );
    
      match p.origin ()
      pick u weave (
         body_with_clauses => @ & "with \e<p.original_name>;\n",
         body_use_clauses => @ & "use \e<p.original_name>;\n"
      );
   }

   match ((w: w_WithClause () and c: has'"with") or (w: w_UseClause () and c: has'"use"))
    and parent (u: w_Unit ()) {
      match origin (child (r: Name()))
        and (r.p_referenced_decl ().template (child (n: w_DefiningName ())))
            pick u weave (
               spec_with_clauses => @ & "\e<c> \e<n.name>; \e<c> \e<w.ref>;\n"
            );
      else pick u weave (
         spec_with_clauses => @ & "\e<c> \e<w.ref>;\n"
      );
   }

   match n: w_NamedEntity () 
      and child (s: w_DefiningName ()) 
      and n.name ("^$") {

      match v: n.origin.p_fully_qualified_name ()
         weave (name => s.name, original_name => v);
      else
         weave (name => s.name);
   }
   
   match w_Unit () and child (p: w_PackageDecl ()) {
      wrap spec_file
         (path => lambda (replace_text (to_lower (p.name), "\\.", "-")) & ".ads", content => self.spec_text);

      match child (w_SubpDecl ()) or p (elaborate_body (".+"))
      wrap body_file 
         (path => lambda (replace_text (to_lower (p.name), "\\.", "-")) & ".adb", content => self.body_text);
   }
}

visitor wrap_ada_specs () {
   match AdaNode ()
   wrap ada_to_wrappers ();

   match w_Ada ()
   wrap wrappers_post_process ();
}
