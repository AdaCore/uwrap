import ada.wrappers;

visitor access_into_out () {
   match ParamSpec("access .*") and parent (sb: SubpDecl()) and child (te: TypeExpr ())
   wrap with w_ParamSpec (
      pre_call_decl => """\e<sb.tmp ("call")> : aliased \e<te.child (TypeExpr ())> with Address => \e<name>'Address, Import;""",
      actual_value => """\e<sb.tmp ("call")>'Unchecked_Access""",
      mode => "out",
      type_expr => lambda (new.child (w_TypeExpr()).child (w_TypeExpr ()).txt)
   );
}

visitor access_into_return (parameter) {
   match parameter.child (TypeExpr (child (te: TypeExpr ()))) {
      wrap with w_SubpDecl
         (call_stmt => "\e<call>;", 
          return_stmt => "null;",
          function_or_procedure => "function");

      wrap parameter with w_ParamSpec (
         generate_formal => "NO",  # TODO: introduce boolean here instead
         actual_value => """\e<self.tmp("call")>'Unchecked_Access""",
         call_decl => """
            \e<self.tmp("call")> : aliased \e<te>;
            \e<self.tmp("ret")>  : aliased \e<result_type_expr> with Address => \e<self.tmp("call")>'Address, Import;
            """,
         return_stmt => """return \e<self.tmp("ret")>;""",
         result_type_expr => lambda (te.template (w_TypeExpr()).txt));
   }
}

visitor constant_into_enumeration (type_name, lit_name) {
   match d: NumberDecl(child (n: DefiningName ())) and parent (template (p: w_PackageDecl())) {
      wrap with null (w_NumberDecl);
      wrap n with null (w_DefiningName);

      match t: p.child (w_TypeDecl (name (type_name)) or new (w_TypeDecl (name => type_name, kind => "enumeration"))) {
         weave t.child (new (w_EnumLiteralDecl (name => lit_name)));
         weave t.child (new (w_EnumRep (name => lit_name, value => d.f_expr)));
      }
   }
}

visitor chars_into_string () {
   match ParamSpec("Interfaces.C.Strings.chars_ptr") and parent (sb: SubpDecl())
   wrap with w_ParamSpec (
      type_expr => "String",
      pre_call_decl => """\e<sb.tmp ("c_string")> : Interfaces.C.Strings.chars_ptr := Interfaces.C.Strings.New_String (\e<name>);\n""",
      actual_value => """\e<sb.tmp ("c_string")>""",
      post_call_stmt => """Interfaces.C.Strings.Free (\e<sb.tmp ("c_string")>);\n"""
   );

   match SubpDecl() and child (TypeExpr ("Interfaces.C.Strings.chars_ptr"))
   wrap with w_SubpDecl (
      function_or_procedure => "function",
      result_type_expr => "String",
      call_decl => """\e<self.tmp ("c_string")> : aliased Interfaces.C.Strings.chars_ptr := \e<call>;\n""",
      call_stmt => "null;", 
      return_stmt => """return Interfaces.C.Strings.Value (\e<self.tmp ("c_string")>);"""
   );
}

template w_ExceptionRegistry {
   var package : text;
   var name : text;
   var init : text;
   var exceptions : text;
}

match w_ExceptionRegistry () {
   match r: self () and u: (
       w_Unit.find (self.child (p: w_PackageDecl(name (r.package))))
         or
       new (w_Unit () [p: w_PackageDecl(name => r.package)])) {

       weave p with (
         spec_content => @ & """
            package \e<p.tmp ("registry_map")> is new Ada.Containers.Ordered_Maps
              (Integer, Ada.Exceptions.Exception_Id, "<", Ada.Exceptions."=");
            \e<name> : \e<p.tmp ("registry_map")>.Map;
            \e<exceptions>""",
         stmt => @ & init
       );

       match not u.child (w_WithClause (ref ("Ada.Exceptions")))
       wrap u.child (new (w_WithClause (ref => "Ada.Exceptions")));

       match not u.child (w_WithClause (ref ("Ada.Containers.Ordered_Maps")))
       wrap u.child (new (w_WithClause (ref => "Ada.Containers.Ordered_Maps")));

       match not p.child (w_SubprogramDecl)
       weave p with (elaborate_body => "pragma Elaborate_Body;\n");
   }
}

visitor error_code_into_exception (package_container, registry_name, exception_name) {
   match d: NumberDecl(child (n: DefiningName ())) {
      wrap with null (w_NumberDecl);
      wrap n with null (w_DefiningName);

      match r: (w_ExceptionRegistry.find (package (package_container) and name (registry_name))
         or new (w_ExceptionRegistry (package => package_container, name => registry_name)))
      weave r with (
         exceptions => @ & "\e<exception_name> : exception;\n",
         init => @ & "\e<registry_name>.Insert (\e<d.f_expr>, \e<exception_name>'Identity);\n"
      );
   }
}

visitor return_into_exception (registry_package, registry_name) {
   match parent (PackageDecl ()).template (p: w_PackageDecl()) {
      match not p.name (registry_package) 
         and u: p.parent (w_Unit ()) {
            match not u.child (w_WithClause (ref (registry_package)))
            wrap u.child (new (w_WithClause (ref => registry_package)));

            match not u.child (w_WithClause (ref ("Ada.Exceptions")))
            wrap u.child (new (w_WithClause (ref => "Ada.Exceptions")));
         }
   }

   wrap with w_SubpDecl (
      function_or_procedure => "procedure",
      call_decl => """\e<self.tmp ("res")> : Interfaces.C.int := \e<call>;\n""",
      call_stmt => "null;", 
      post_call_stmt => """
         if not Interfaces.C."=" (\e<self.tmp ("res")>, 0) then
            Ada.Exceptions.Raise_Exception
               (\e<registry_package>.\e<registry_name>.Element (Integer (\e<self.tmp ("res")>)));
         end if;
      """
   );
}