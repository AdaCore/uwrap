import ada.wrappers;

visitor access_into_out () {
   match ParamSpec("access .*") and parent (sb: SubpDecl()) and child (te: TypeExpr ())
   wrap w_ParamSpecCall (
      pre_call_decl => """\e<sb.tmp ("call")> : aliased \e<te.child (TypeExpr ())> with Address => \e<name>'Address, Import;""",
      actual_value => """\e<sb.tmp ("call")>'Unchecked_Access""",
      mode => "out",
      type_expr => lambda (new.child (w_TypeExpr()).child (w_TypeExpr ()).txt)
   );
}

visitor access_into_return (parameter) {
   match parameter.child (TypeExpr (child (te: TypeExpr ()))) {
      wrap w_SubpDeclCall (
         call_stmt => "\e<call>;", 
         return_stmt => "null;",
         function_or_procedure => "function");

      pick parameter wrap w_ParamSpecCall (
         generate_formal => "NO",  # TODO: introduce boolean here instead
         actual_value => """\e<self.tmp("call")>'Unchecked_Access""",
         call_decl => """
            \e<self.tmp("call")> : aliased \e<te>;
            \e<self.tmp("ret")>  : aliased \e<result_type_expr> with Address => \e<self.tmp("call")>'Address, Import;
            """,
         return_stmt => """return \e<self.tmp("ret")>;""",
         result_type_expr => lambda (te.template (w_TypeExpr()).txt));
   }
}

visitor constant_into_enumeration (type_name, lit_name) {
   match d: NumberDecl(child (n: DefiningName ())) and parent (template (p: w_PackageDecl())) {
      wrap null (w_NumberDecl);
      pick n wrap null (w_DefiningName);

      match t: p.child (w_TypeDecl (name (type_name)) or new (w_TypeDecl (name => type_name, kind => "enumeration"))) {
         pick t.child (new (w_EnumLiteralDecl (name => lit_name)));
         pick t.child (new (w_EnumRep (name => lit_name, value => d.f_expr)));
      }
   }
}

visitor chars_into_string () {
   match ParamSpec("Interfaces.C.Strings.chars_ptr") and parent (sb: SubpDecl())
   wrap w_ParamSpecCall (
      type_expr => "String",
      pre_call_decl => """\e<sb.tmp ("c_string")> : Interfaces.C.Strings.chars_ptr := Interfaces.C.Strings.New_String (\e<name>);\n""",
      actual_value => """\e<sb.tmp ("c_string")>""",
      post_call_stmt => """Interfaces.C.Strings.Free (\e<sb.tmp ("c_string")>);\n"""
   );

   match SubpDecl() and child (TypeExpr ("Interfaces.C.Strings.chars_ptr"))
   wrap w_SubpDeclCall (
      function_or_procedure => "function",
      result_type_expr => "String",
      call_decl => """\e<self.tmp ("c_string")> : aliased Interfaces.C.Strings.chars_ptr := \e<call>;\n""",
      call_stmt => "null;", 
      return_stmt => """return Interfaces.C.Strings.Value (\e<self.tmp ("c_string")>);"""
   );
}

template w_ExceptionRegistry {
   var package : text;
   var name : text;
   var init : text;
   var exceptions : text;
}

match w_ExceptionRegistry () {
   match r: self () and u: (
       w_Unit.find (self.child (p: w_PackageDecl(name (r.package))))
         or
       new (w_Unit () [p: w_PackageDecl(name => r.package)])) {

      pick p weave (
         spec_content => @ & """
            package \e<p.tmp ("registry_map")> is new Ada.Containers.Ordered_Maps
              (Integer, Ada.Exceptions.Exception_Id, "<", Ada.Exceptions."=");
            \e<r.name> : \e<p.tmp ("registry_map")>.Map;
            \e<r.exceptions>""",
         stmt => @ & r.init
       );

      match not u.child (w_WithClause (ref ("Ada.Exceptions")))
      pick u.child (new (w_WithClause (ref => "Ada.Exceptions")));

      match not u.child (w_WithClause (ref ("Ada.Containers.Ordered_Maps")))
      pick u.child (new (w_WithClause (ref => "Ada.Containers.Ordered_Maps")));

      match not p.child (w_SubprogramDecl)
      pick p weave (elaborate_body => "pragma Elaborate_Body;\n");
   }
}

visitor error_code_into_exception (package_container, registry_name, exception_name) {
   match (dnum: NumberDecl (child (n: DefiningName ()) and expr: f_expr)
       or dobj: ObjectDecl ((child (n: DefiningName ())) and expr: f_default_expr)) {

      match dnum ()
      wrap null (w_NumberDecl);

      match dobj ()
      wrap null (w_ObjectDecl);

      pick n wrap null (w_DefiningName);

      match r: (w_ExceptionRegistry.find (package (text (package_container)) and name (text (registry_name)))
         or new (w_ExceptionRegistry (package => text (package_container), name => text (registry_name))))
      pick r weave (
         exceptions => @ & "\e<exception_name> : exception;\n",
         init => @ & "\e<registry_name>.Insert (Integer (\e<expr>), \e<exception_name>'Identity);\n"
      );
   }
}

visitor into_binary_compatible (type_name) {
   match ParamSpec() and parent (sb: SubpDecl ())
   wrap w_ParamSpecCall(
      type_expr => type_name,
      pre_call_decl => """\e<sb.tmp ("local")> : aliased \e<p_type_expression> with Address => \e<name>'Address, Import;\n""",
      actual_value => sb.tmp ("local")
   );

   match child (f_subp_kind ("function")) and child (te: TypeExpr()) 
   wrap w_SubpDeclCall
      (function_or_procedure => "function",
       result_type_expr => type_name,
       call_decl => """\e<self.tmp ("result_orig")> : aliased \e<te> := \e<call>;\n""",
       post_call_decl => """
         \e<self.tmp ("result_wrapped")> : aliased \e<type_name> 
         with Address => \e<self.tmp ("result_orig")>'Address, Import;\n""",
       call_stmt => "null;", 
       return_stmt => """return \e<self.tmp ("result_wrapped")>;""");
}

visitor parameter_into_computed_expression (expr) {
   match ParamSpec()
   wrap w_ParamSpecCall(
      generate_formal => "NO",
      type_expr => "",
      actual_value => expr
   );
}

visitor return_into_exception (registry_package, registry_name) {
   match parent (PackageDecl ()).template (p: w_PackageDecl()) {
      match not p.name (registry_package) 
         and u: p.parent (w_Unit ()) {
            match not u.child (w_WithClause (ref (registry_package)))
            pick u.child (new (w_WithClause (ref => registry_package)));

            match not u.child (w_WithClause (ref ("Ada.Exceptions")))
            pick u.child (new (w_WithClause (ref => "Ada.Exceptions")));
         }
   }

   wrap w_SubpDeclCall (
      function_or_procedure => "procedure",
      call_decl => """\e<self.tmp ("res")> : Integer := Integer (\e<call>);\n""",
      call_stmt => "null;", 
      post_call_stmt => """
         if \e<self.tmp ("res")> /= 0 then
            Ada.Exceptions.Raise_Exception
               (\e<registry_package>.\e<registry_name>.Element (Integer (\e<self.tmp ("res")>)));
         end if;
      """
   );
}