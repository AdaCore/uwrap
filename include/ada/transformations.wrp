import ada.wrappers;

visitor access_into_out () {
   match ParamSpec("access .*") and parent (sb: SubpDecl()) and child (te: TypeExpr ())
   wrap with w_ParamSpec (
      pre_call_decl => "\e<sb.tmp ('call')> : aliased \e<te.child (TypeExpr ())> with Address => \e<name>'Address, Import;",
      actual_value => "\e<sb.tmp ('call')>'Unchecked_Access",
      mode => "out",
      type_expr => lambda (new.child (w_TypeExpr()).child (w_TypeExpr ()).txt)
   );
}

visitor access_into_return (parameter) {
   match parameter.child (TypeExpr (child (te: TypeExpr ()))) {
      wrap with w_SubpDecl
         (call_stmt => "\e<call>;", 
          return_stmt => "null;",
          function_or_procedure => "function");

      wrap parameter with w_ParamSpec (
         generate_formal => "NO",  # TODO: introduce boolean here instead
         actual_value => "\e<self.tmp('call')>'Unchecked_Access",
         call_decl => """
            \e<self.tmp('call')> : aliased \e<te>;
            \e<self.tmp('ret')>  : aliased \e<result_type_expr> with Address => \e<self.tmp('call')>'Address, Import;
            """,
         return_stmt => "return \e<self.tmp('ret')>;",
         result_type_expr => lambda (te.template (w_TypeExpr()).txt));
   }
}

visitor constant_into_enumeration (type_name, lit_name) {
   match d: NumberDecl(child (n: DefiningName ())) and parent (template (p: w_PackageDecl())) {
      wrap with null (w_NumberDecl);
      wrap n with null (w_DefiningName);

      match t: p.child (w_TypeDecl (name (type_name)) or new (w_TypeDecl (name => type_name, kind => "enumeration"))) {
         weave t.child (new (w_EnumLiteralDecl (name => lit_name)));
         weave t.child (new (w_EnumRep (name => lit_name, value => d.f_expr)));
      }
   }
}

visitor chars_into_string () {
   match ParamSpec("Interfaces.C.Strings.chars_ptr") and parent (sb: SubpDecl())
   wrap with w_ParamSpec (
      type_expr => "String",
      pre_call_decl => "\e<sb.tmp ('c_string')> : Interfaces.C.Strings.chars_ptr := Interfaces.C.Strings.New_String (\e<name>);\n",
      actual_value => "\e<sb.tmp ('c_string')>",
      post_call_stmt => "Interfaces.C.Strings.Free (\e<sb.tmp ('c_string')>);\n"
   );

   match SubpDecl() and child (TypeExpr ("Interfaces.C.Strings.chars_ptr"))
   wrap with w_SubpDecl (
      function_or_procedure => "function",
      result_type_expr => "String",
      call_decl => "\e<self.tmp ('c_string')> : aliased Interfaces.C.Strings.chars_ptr := \e<call>;\n",
      call_stmt => "null;", 
      return_stmt => "return Interfaces.C.Strings.Value (\e<self.tmp ('c_string')>);"
   );
}
